
# Overview of Prisma

Prisma provides a modern, intuitive way to interact with databases, simplifying the process of writing raw SQL queries and managing migrations. It includes several components that work together to streamline database operations for developers.

## Prisma Overview
Prisma is an open-source database toolkit that integrates tools such as an Object-Relational Mapper (ORM), various engines for executing database operations, and a command-line interface (CLI) for automation. These components create a cohesive ecosystem that improves productivity and developer experience by simplifying database interactions.

### 1. Prisma Components
Prisma consists of three primary components that work together:

## Visual Representation of Prisma Components


- **Prisma CLI**: The command-line tool that developers use to interact with Prisma. It manages the configuration, generates the Prisma Client, and handles migrations. The CLI is essential for tasks like initializing a new project (`prisma init`), managing schema migrations (`prisma migrate`), and generating code (`prisma generate`).
  
- **Prisma Client**: An auto-generated and type-safe query builder that allows developers to interact with the database. It provides a type-safe way to access and manipulate data, ensuring developers can write database queries directly in their code with reduced risk of errors.
  
- **Prisma Engines**: These are the underlying components that handle specific operations requested by Prisma Client or Prisma CLI:
  - **Query Engine**: Executes database queries generated by Prisma Client and optimizes them to be executed efficiently.
  - **Migration Engine**: Generates and executes migration scripts to modify the database schema when you change your Prisma model definitions.
  - **Introspection Engine**: Reads the current state of an existing database schema, which helps in importing or working with an existing database in a Prisma project.

### 2. Prisma Workflow
The interaction between the Prisma components works as follows:

1. **Prisma CLI** is used to initialize projects, define schemas, generate migrations, and generate the Prisma Client.
2. **Prisma Engines** power the CLI commands and Prisma Client operations.
   - The **Migration Engine** handles migrations that are generated and applied through CLI commands.
   - The **Introspection Engine** helps the CLI to generate Prisma schema by introspecting an existing database.
3. The **Prisma Client**, generated by the CLI, interacts with the **Query Engine** to execute queries against the database efficiently.

```mermaid
graph LR
    A[Prisma CLI] --> B[Prisma Client]
    B --> C[Query Engine]
    A[Prisma CLI]:::cli -->|Generates| B[Prisma Client]:::client
    B[Prisma Client]:::client -->|Uses| C[Query Engine]:::engine
    
    classDef cli fill:gray,stroke:#333,stroke-width:2px;
    classDef client fill:#0df,stroke:#333,stroke-width:2px;
    classDef engine fill:#bfb3F,stroke:#333,stroke-width:2px;
```


In summary, Prisma CLI, Prisma Client, and Prisma Engines work together to facilitate efficient and safe database interactions. The CLI automates setup, migrations, and client generation, while the engines power these operations under the hood. Together, they provide a streamlined experience for developers managing databases in modern applications.

### 3. Basic Prisma CLI Commands
Here are some of the key commands used with Prisma CLI:
- **`prisma init`**: Initializes a new Prisma project by creating configuration files such as `schema.prisma`.
- **`prisma migrate dev`**: Generates migration scripts for schema changes and applies them to the database in a development environment.
- **`prisma migrate deploy`**: Applies pending migrations to the production database.
- **`prisma generate`**: Generates the Prisma Client, allowing you to interact with the database in a type-safe way.
- **`prisma introspect`**: Reads an existing database schema and generates a corresponding Prisma schema (`schema.prisma`).
- **`prisma studio`**: Opens Prisma Studio, a GUI for exploring and manipulating the data in your database.
- **`prisma format`**: Formats the Prisma schema file to ensure it is neat and follows the correct conventions.
Here’s how the Prisma components interact with each other:



## Where to Execute Prisma Migrations

- **Development Environment**: Use `prisma migrate dev` to iterate quickly on changes.
- **Production Environment**: Use `prisma migrate deploy` to apply migrations safely in a controlled environment.

**Best Practice**: Always use migrations in a staging environment first before applying them to production, to catch any issues early.

## How to Execute Prisma Migrations

- **Development**:
  - Run `prisma migrate dev` whenever you make changes to the Prisma schema. This will generate the migration files and apply them automatically.

- **Staging/Production**:
  - First, run `prisma migrate deploy` on the staging environment. Ensure everything works properly.
  - After validation, apply the migrations to the production environment using the same command.

**CI/CD Integration**: Prisma CLI commands can be executed as part of your CI/CD pipelines to automate the deployment of database changes.

## Support for SQL Artifacts and Automatic Detection

Prisma also has the ability to detect existing database schemas and generate Prisma models that match your current state through introspection:

- **`prisma introspect`**: Reads the existing state of your database schema and updates your `schema.prisma` file accordingly.

  ```bash
  prisma introspect
  ```
  
This command helps developers working with an existing database to automatically generate Prisma schema artifacts, providing a smoother transition from other ORM systems or manual SQL management.

Additionally, Prisma migration files are essentially SQL scripts under the hood, and they can be reviewed, edited, or executed directly if needed. This makes it easier for developers to understand what changes are being applied and provides more control over the migration process.

## Summary of Execution Steps

1. **Install Prisma CLI** using npm.
2. **Define schema changes** in `schema.prisma`.
3. **Create migrations** using `prisma migrate dev`.
4. **Run custom data migration scripts**, if needed, using Prisma Client.
5. **Apply migrations in production** using `prisma migrate deploy`.
6. Use **introspection** to generate or update Prisma schemas based on an existing database.

Prisma’s migration workflow is powerful, leveraging a combination of schema management, data migrations, and introspection, all powered by high-performance Rust engines that provide a reliable and efficient way to handle database operations.



### Capitalized Table and Column Names in Prisma

Prisma automatically handles table and column names, which can include capitalized or mixed-case names, ensuring they are compatible with the database you are using. Here’s how Prisma manages this:

- **Automatic Normalization**: When you define model names or field names in Prisma, they are usually represented as they appear in your Prisma schema (`schema.prisma`). Prisma takes care of mapping these names to the correct format as required by your specific database. For instance:
  - If you use capitalized or mixed-case names, Prisma will appropriately map those to the format required by the underlying database, including adding quotes if the database is case-sensitive.
- **Database Compatibility**: Certain databases like PostgreSQL are case-sensitive for table and column names, while others like MySQL are not. Prisma handles these differences internally by applying quotes where necessary, so you don’t need to worry about inconsistencies between your code and your database.
- **Mapping Names with @map and @@map**: You can use the `@map` attribute to map individual field names and the `@@map` attribute to map model names to different table or column names in the database. This allows you to follow a naming convention in your code that differs from the underlying database.

For example:
```prisma
model User {
  Id        Int     @id @default(autoincrement())
  FirstName String
  LastName  String
}
```
If the underlying database is PostgreSQL, Prisma will ensure that `"User"`, `"FirstName"`, and `"LastName"` are properly handled, even though PostgreSQL treats identifiers as case-sensitive if they are quoted.

To learn more about this, refer to the [Prisma Documentation on Database Mapping](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping).

### Type Mapping with Prisma

Prisma provides a set of scalar types that can be mapped to the underlying database types, but the exact type mapping may vary depending on the database provider you use. Here's how Prisma deals with type mapping:

- **Database-Specific Type Mapping**: Prisma supports different databases like PostgreSQL, MySQL, SQLite, and SQL Server, and each of these databases has its own set of native types. Prisma’s scalar types (such as `String`, `Int`, `Float`, etc.) are automatically mapped to the corresponding database types depending on the specific database used.
  - For instance, a `String` type in Prisma might map to `VARCHAR` in MySQL, but to `TEXT` in PostgreSQL, depending on the column configuration.
  - Similarly, `Int` in Prisma could be mapped to `INTEGER` or `INT4`, depending on the database.
- **Native Type Annotations**: Prisma allows you to specify native types using `@db.<type>` annotations to have better control over the underlying type if needed.
  - Example for PostgreSQL:
    ```prisma
    model Product {
      id    Int     @id @default(autoincrement())
      price Float   @db.Decimal(10, 2)
    }
    ```
    In this example, the `@db.Decimal(10, 2)` annotation tells Prisma to use the `DECIMAL` type with precision 10 and scale 2 in PostgreSQL, giving you better control over how the data is represented.

For more information, see the [Prisma Documentation on Type Mapping](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#type-mapping).

This flexible type mapping approach ensures that Prisma can work consistently across different databases, while also allowing you to handle specific database needs using native type annotations if necessary. This abstraction reduces the amount of database-specific code you need to write and helps maintain consistency across different environments.

### Summary

- **Capitalized Table and Column Names**: Prisma automatically handles the capitalization and case-sensitivity requirements based on the database type, ensuring consistency. You can also use `@map` and `@@map` to manually control table and field naming.
- **Type Mapping**: Prisma’s scalar types are mapped to database-specific types internally, and you can use native type annotations to control the underlying database types explicitly, adapting to differences between various database systems.


# Foreign Keys and Relationships in Prisma Schema

Foreign keys in a database schema are crucial for establishing relationships between different tables, ensuring data integrity by linking related records. In Prisma, foreign keys are defined implicitly through relation fields in your schema, which represent relationships between two or more models.

## Types of Relationships in Prisma Schema

### One-to-One (1:1) Relationship
This relationship implies that a single record in one table is related to a single record in another table.

For example, a `User` may have one `Profile`. You establish this relationship in Prisma using a foreign key in one of the models and adding a `relation` attribute.

```prisma
model User {
  id      Int     @id @default(autoincrement())
  profile Profile?
}

model Profile {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique
}
```

In this example, the `Profile` model has a foreign key `userId` that references `User`'s `id` field, creating a one-to-one relationship.

### One-to-Many (1:N) Relationship
This type of relationship means that a single record in one table relates to multiple records in another table.

For example, a `User` can have many `Posts`, but each `Post` belongs to a single `User`.

```prisma
model User {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

model Post {
  id     Int  @id @default(autoincrement())
  title  String
  user   User @relation(fields: [userId], references: [id])
  userId Int
}
```

Here, the `User` model has a list of `Post` instances (`posts`), indicating a one-to-many relationship. The `Post` model contains the foreign key (`userId`) that references the `User` model.

### Many-to-Many (M:N) Relationship
In this relationship, multiple records in one table can relate to multiple records in another table.

Prisma represents many-to-many relationships by creating an implicit join table.

```prisma
model User {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

model Post {
  id     Int    @id @default(autoincrement())
  title  String
  users  User[]
}
```

Prisma automatically creates a join table behind the scenes to link the `User` and `Post` models, enabling a many-to-many relationship.

## Relation Fields in the Schema
Relation fields in Prisma schemas are fields that define relationships between different models. They are crucial for representing how models are linked, and they often use foreign key fields to establish these links.

- **Fields for Relationships**: The relation field typically references another model and may include additional metadata such as foreign key constraints.
- **Defining Foreign Keys**: In Prisma, foreign keys are defined by specifying the fields used for referencing and indicating which field they refer to in the related model using the `@relation` attribute.

Using the `@relation` attribute helps specify how Prisma should enforce and manage relationships in the underlying database, ensuring referential integrity and making it easy to navigate related data.

For more detailed information, refer to:
- [Prisma One-to-Many Relationships](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations)
- [Prisma Relations Overview](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations)


# SQL Views Support in Prisma

Prisma does not natively support SQL Views as part of its core feature set, but you can use an experimental feature to work with views by enabling it through the `previewFeatures` option in your Prisma schema.

## Enabling SQL Views with Prisma

To use SQL views in Prisma, you need to enable the experimental feature by adding `"views"` to the `previewFeatures` array in your `schema.prisma` file. This feature is currently under preview, meaning it's not fully stable, but it can be used for advanced scenarios where SQL views are required.

Here is how to enable the experimental views feature:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}
```

## Creating SQL Views with Custom Migration Scripts

Since SQL views are not natively managed by Prisma's migration engine, they must be created using custom SQL migration scripts. You can create a new migration script to add a view to your database as follows:

1. **Generate a New Migration Script**: First, use the Prisma CLI to create a new migration.
   ```sh
    prisma migrate dev --create-only
   ```
   This command will generate a new migration file that you can modify to add your custom SQL view.

2. **Modify the Migration Script**: Open the newly created migration script file located in the `prisma/migrations/` directory. Add the SQL code required to create your view. For example:
   ```sql
   CREATE VIEW "UserWithPosts" AS
   SELECT u.id, u.name, COUNT(p.id) AS post_count
   FROM "User" u
   LEFT JOIN "Post" p ON u.id = p."userId"
   GROUP BY u.id, u.name;
   ```

3. **Apply the Migration**: Apply the migration using the Prisma CLI.
   ```sh
    prisma migrate dev
   ```

This custom approach allows you to create and manage SQL views while using Prisma as your ORM. Since SQL views are not directly managed by the Prisma schema, you must manually update or delete them by modifying the corresponding migration files when needed.

## Reference

For more information on using the Prisma CLI and managing migrations, refer to the official documentation: [Prisma CLI Reference](https://www.prisma.io/docs/orm/reference/prisma-cli-reference).




# Customizing Prisma Migrations to Avoid Data Loss

When working with migrations in Prisma, especially for tasks such as renaming columns or tables, it's important to avoid data loss that might occur due to the way default migration scripts are generated. By default, Prisma may generate migration scripts that drop and recreate tables or columns, which can lead to data loss if not handled properly.

To prevent this, you can manually modify the generated migration scripts to replace `DROP` and `CREATE` commands with `RENAME` commands. This ensures that data is preserved during changes. The recommended approach is to use the `prisma migrate dev --create-only` command to generate the migration script first, and then edit the SQL file as needed.

## Steps to Customize Migrations to Avoid Data Loss

1. **Generate Migration Script**: Use the Prisma CLI to generate a new migration script. This script will contain the default changes Prisma thinks should be made, which may include dropping and recreating columns or tables.

   ```sh
    prisma migrate dev --create-only
   ```
   This command creates a migration script without applying it immediately. The migration file will be located in the `prisma/migrations/` directory.

2. **Modify the Generated SQL Script**: Open the generated migration file and locate any `DROP` and `CREATE` commands for tables or columns that you intend to rename. Modify these commands to use `RENAME` instead. For example:

   ```sql
   -- Original generated script
   ALTER TABLE "User" DROP COLUMN "oldColumnName";
   ALTER TABLE "User" ADD COLUMN "newColumnName" VARCHAR;

   -- Modified script to avoid data loss
   ALTER TABLE "User" RENAME COLUMN "oldColumnName" TO "newColumnName";
   ```

3. **Apply the Modified Migration**: After modifying the migration script, apply it using the Prisma CLI.

   ```sh
    prisma migrate dev
   ```

By manually modifying the migration file, you ensure that columns or tables are renamed instead of being dropped and recreated, which helps avoid losing any existing data.

## Important Tips
- Always backup your database before applying migrations, especially when making manual changes.
- Test the migration on a development or staging environment before applying it to production.

## Reference

For more information on customizing migrations, refer to the official documentation: [Customizing Prisma Migrations](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations).




# Moving to Prisma

If you are transitioning to Prisma for managing your database, here are the steps you need to follow to set up Prisma with your existing database. Prisma helps you create a schema and generates a type-safe client, making it easy to interact with your database.

## Steps to Migrate to Prisma

### 1. Set the `DATABASE_URL` in the `.env` File
The `DATABASE_URL` environment variable is used to specify the connection string for your existing database. You need to set this value in the `.env` file.

For example, if you are using MySQL, your `.env` file might look like this:

```env
DATABASE_URL="mysql://user:password@localhost:3306/mydatabase"
```

Make sure the `DATABASE_URL` points to your existing database with the correct credentials, hostname, and database name.

### 2. Set the Provider in the `schema.prisma` File
Next, you need to update the `schema.prisma` file to match your database type. In the `datasource` block, set the `provider` field to your database. This can be `mysql`, `postgresql`, `sqlite`, etc.

For example, if you are using MySQL:

```prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

This tells Prisma what type of database it is working with, using the connection string from the `.env` file.

### 3. Run `prisma db pull` to Create the Prisma Schema
To create a Prisma schema that reflects your existing database structure, run the following command:

```sh
 prisma db pull
```

This command introspects your existing database and creates a `schema.prisma` file with the tables and columns found in the database. The generated schema represents the current state of your database.

### 4. Run `prisma generate` to Generate Prisma Client
After creating the Prisma schema, you need to generate the Prisma Client. The Prisma Client is an auto-generated, type-safe query builder that you can use to interact with your database.

Run the following command:

```sh
 prisma generate
```

This command will generate the Prisma Client based on your `schema.prisma` file. You can then start using the client in your code to query your database.

For example, in a JavaScript or TypeScript file:

```js
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  const users = await prisma.user.findMany();
  console.log(users);
}

main()
  .catch(e => {
    throw e;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

### Summary of Commands
1. Set `DATABASE_URL` in `.env` to point to your existing database.
2. Set the provider of the datasource block in `schema.prisma` to match your database type.
3. Run ` prisma db pull` to create a Prisma schema from your existing database.
4. Run ` prisma generate` to generate the Prisma Client, and start querying your database.

## Reference
For more detailed information, you can visit [Prisma's Official Documentation](https://www.prisma.io/docs/).


# Moving to Prisma

If you are transitioning to Prisma for managing your database, here are the steps you need to follow to set up Prisma with your existing database. Prisma helps you create a schema and generates a type-safe client, making it easy to interact with your database.

## Steps to Migrate to Prisma

### 1. Set the `DATABASE_URL` in the `.env` File
The `DATABASE_URL` environment variable is used to specify the connection string for your existing database. You need to set this value in the `.env` file.

For example, if you are using MySQL, your `.env` file might look like this:

```env
DATABASE_URL="mysql://user:password@localhost:3306/mydatabase"
```

Make sure the `DATABASE_URL` points to your existing database with the correct credentials, hostname, and database name.

### 2. Set the Provider in the `schema.prisma` File
Next, you need to update the `schema.prisma` file to match your database type. In the `datasource` block, set the `provider` field to your database. This can be `mysql`, `postgresql`, `sqlite`, etc.

For example, if you are using MySQL:

```prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

This tells Prisma what type of database it is working with, using the connection string from the `.env` file.

### 3. Run `prisma db pull` to Create the Prisma Schema
To create a Prisma schema that reflects your existing database structure, run the following command:

```sh
 prisma db pull
```

This command introspects your existing database and creates a `schema.prisma` file with the tables and columns found in the database. The generated schema represents the current state of your database.

### 4. Run `prisma generate` to Generate Prisma Client
After creating the Prisma schema, you need to generate the Prisma Client. The Prisma Client is an auto-generated, type-safe query builder that you can use to interact with your database.

Run the following command:

```sh
 prisma generate
```

This command will generate the Prisma Client based on your `schema.prisma` file. You can then start using the client in your code to query your database.

### Example Usage in Python

Prisma also supports a Python client, which allows you to interact with your database in Python projects.

1. **Install the Prisma Client for Python**:
   You need to install the Prisma Python client using pip:
   ```sh
   pip install prisma
   ```

2. **Generate the Python Client**:
   After installing the Prisma client for Python, generate the client with the following command:
   ```sh
   prisma generate
   ```

3. **Usage in Python Code**:
   You can now start using the Prisma client in your Python scripts to query the database:

   ```python
   from prisma import Prisma

   prisma = Prisma()

   async def main():
       await prisma.connect()

       users = await prisma.user.find_many()
       print(users)

       await prisma.disconnect()

   import asyncio
   asyncio.run(main())
   ```

### Summary of Commands
1. Set `DATABASE_URL` in `.env` to point to your existing database.
2. Set the provider of the datasource block in `schema.prisma` to match your database type.
3. Run ` prisma db pull` to create a Prisma schema from your existing database.
4. Run ` prisma generate` to generate the Prisma Client.
5. Install Prisma Python client (`pip install prisma`).
6. Use Prisma client in your Python code to start querying the database.

## Reference
For more detailed information, you can visit [Prisma's Official Documentation](https://www.prisma.io/docs/).